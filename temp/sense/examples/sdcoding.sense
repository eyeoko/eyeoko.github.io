% Superdense coding using discrete quantum computing

% See https://arxiv.org/pdf/1101.3764.pdf and arxiv.org/pdf/1010.2929.pdf

% Discrete quantum theory is obtained by instantiating the mathematical framework
% of Hilbert spaces with a finite field instead of the field of complex numbers.
% This instantiation collapses much the structure of actual quantum mechanics but
% retains several of its distinguishing characteristics including the notions of
% superposition, interference, and entanglement. Furthermore, discrete quantum
% theory excludes local hidden variable models, has a no-cloning theorem, and can
% express natural counterparts of quantum information protocols such as superdense
% coding and teleportation.

% Surprisingly discrete quantum computing is identical to conventional logic
% programming except for a small twist that is responsible for all the
% "quantum-ness". The twist occurs when merging sets of answers computed by
% several alternatives: the answers are combined using an exclusive version of
% logical disjunction. In other words, the two branches of a choice junction
% exhibit an interference effect: an answer is produced from the junction if it
% occurs in one or the other branch but not both.

'sense:builtin'(dynamic('sense:sdcoding'/2),-).

% |R) = |0, 0) + |1, 1)
'eg:r'(false,false).
'eg:r'(true,true).

% |S) = |0, 1) + |1, 0)
'eg:s'(false,true).
'eg:s'(true,false).

% |U) = |0, 0) + |1, 0) + |1, 1)
'eg:u'(false,false).
'eg:u'(true,false).
'eg:u'(true,true).

% |V ) = |0, 0) + |0, 1) + |1, 0)
'eg:v'(false,false).
'eg:v'(false,true).
'eg:v'(true,false).

% ID |0) = |0)
'eg:id'(false,false).
% ID |1) = |1)
'eg:id'(true,true).

% G |0) = |1)
'eg:g'(false,true).
% G |1) = |0)
'eg:g'(true,false).

% K |0) = |0)
'eg:k'(false,false).
% K |1) = |0) + |1)
'eg:k'(true,false).
'eg:k'(true,true).

% KG
'eg:kg'(X,Y) <= 'eg:g'(X,Z),'eg:k'(Z,Y).

% GK
'eg:gk'(X,Y) <= 'eg:k'(X,Z),'eg:g'(Z,Y).

% alice
'eg:alice'(0,[X,Y]) <= 'eg:id'(X,Y).
'eg:alice'(1,[X,Y]) <= 'eg:g'(X,Y).
'eg:alice'(2,[X,Y]) <= 'eg:k'(X,Y).
'eg:alice'(3,[X,Y]) <= 'eg:kg'(X,Y).

% bob
'eg:bob'([X,Y],0) <= 'eg:gk'(X,Y).
'eg:bob'([X,Y],1) <= 'eg:k'(X,Y).
'eg:bob'([X,Y],2) <= 'eg:g'(X,Y).
'eg:bob'([X,Y],3) <= 'eg:id'(X,Y).

% superdense coding
'sense:sdc'(N,M) <=
    'eg:r'(X,Y),
    'eg:alice'(N,[X,B]),
    'eg:bob'([B,Y],M),
    'sense:sd'(N,M).

% asserting sdcoding an odd number of times
'sense:sd'(N,M) <=
    'sense:sdcoding'(N,M),
    'sense:builtin'(!,-),
    'sense:builtin'(retract('sense:sdcoding'(N,M)),-).
'sense:sd'(N,M) <=
    'sense:builtin'(assert('sense:sdcoding'(N,M)),-).

% superdense coding appearing an odd number of times
'sense:sdc'(N,M) => 'sense:sdconot'(N,M).

% query
'sense:sdcoding'(_N,_M) => true.
