% --------------------------------------------------------
% The elf engine written in the elf language -- Jos De Roo
% --------------------------------------------------------
%
% See https://josd.github.io/elf/
%

'elf:directive'(use_module(library(lists)),-).
'elf:directive'(use_module(library(terms)),-).
'elf:directive'(use_module(library(iso_ext)),-).

'elf:directive'(dynamic((=>)/2),-).
'elf:directive'(dynamic((<=)/2),-).
'elf:directive'(dynamic('elf:brake'/2),-).
'elf:directive'(dynamic('elf:witness_count'/2),-).
'elf:directive'(dynamic('elf:domain_predicate'/2),-).
'elf:directive'(dynamic('elf:answer'/2),-).

%
% elf abstract machine
%
% 1/ select rule P => C
% 2/ prove P and if it fails backtrack to 1/
% 3/ if C = true answer with P => true, else if ~C assert C and retract brake
% 4/ backtrack to 2/ and if it fails backtrack to 1/
% 5/ if 1/ fails and if brake halt, else assert brake and start again at 1/
%
'elf:main'(-,-) <=
    'elf:control'(call((Prem => Conc)),-),
    'elf:control'(call(Prem),-),
    'elf:process'(Prem,Conc),
    'elf:control'(fail,-).
'elf:main'(_,-) <=
    'elf:brake'(-,-),
    'elf:builtin'(halt,-).
'elf:main'(-,-) <=
    'elf:builtin'(asserta('elf:brake'(-,-)),-),
    'elf:main'(-,-).

'elf:process'(Prem,true) <=
    'elf:labelvars'(Prem,-),
    'elf:add_answer'(Prem,-).
'elf:process'(Prem,Conc) <=
    'elf:builtin'(\+Conc,-),
    'elf:labelvars'(Conc,-),
    'elf:astep'(Prem,Conc),
    'elf:builtin'(retract('elf:brake'(-,-)),-).

'elf:add_answer'(Prem,-) <=
    'elf:builtin'(\+'elf:answer'((Prem => true),-),-),
    'elf:builtin'(assertz('elf:answer'((Prem => true),-)),-),
    'elf:builtin'(writeq(Prem),-),
    'elf:builtin'(write(' => true.\n'),-).
'elf:add_answer'(_,-).

% create witnesses
'elf:labelvars'(Term,-) <=
    'elf:builtin'(retract('elf:witness_count'(Current,-)),-),
    'elf:control'(!,-),
    'elf:builtin'(numbervars(Term,Current,Next),-),
    'elf:builtin'(assertz('elf:witness_count'(Next,-)),-).
'elf:labelvars'(Term,-) <=
    'elf:builtin'(numbervars(Term,0,Next),-),
    'elf:builtin'(assertz('elf:witness_count'(Next,-)),-).

% assert new step
'elf:astep'(A,(B,C)) <=
    'elf:astep'(A,B),
    'elf:astep'(A,C).
'elf:astep'(A,false) <=
    'elf:builtin'(writeq(A),-),
    'elf:builtin'(write(' => false.\n'),-),
    'elf:builtin'(halt,-).
'elf:astep'(_,A) <=
    'elf:builtin'(\+A,-),
    'elf:builtin'(asserta(A),-),
    'elf:apred'(A,-).
'elf:astep'(_,_).

'elf:apred'(A,-) <=
    'elf:builtin'(functor(A,B,2),-),
    'elf:builtin'(\+'elf:domain_predicate'(B,-),-),
    'elf:builtin'(assertz('elf:domain_predicate'(B,-)),-).
'elf:apred'(_,-).
