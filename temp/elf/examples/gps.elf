% Goal driven Parallel Sequences -- Jos De Roo
% See background paper https://arxiv.org/pdf/2010.12027.pdf

% find paths in the state space from initial state to goal state within limits
'elf:findpath'(_SCOPE,[Goal,Path,Duration,Cost,Belief,Comfort,Limits]) <=
    'elf:findpaths'([],[Goal,[],0.0,0.0,1.0,1.0,Path,Duration,Cost,Belief,Comfort,Limits]).

'elf:findpaths'(_Maps,[Goal,Path,Duration,Cost,Belief,Comfort,Path,Duration,Cost,Belief,Comfort,_Limits]) <=
    'elf:control'(call(Goal),-),
    'elf:control'(!,-).
'elf:findpaths'(Maps_s,[Goal,Path_s,Duration_s,Cost_s,Belief_s,Comfort_s,Path,Duration,Cost,Belief,Comfort,Limits]) <=
    'elf:builtin'(Limits = [MaxDuration,MaxCost,MinBelief,MinComfort,MaxStagecount],-),
    'elf:builtin'(clause(
        'elf:description'(Map,[From,Transition,To,Action,Duration_n,Cost_n,Belief_n,Comfort_n]),
        Where
    ),-),
    'elf:control'(call(From),-),
    'elf:control'(call(Where),-),
    'elf:description'(Map,[From,Transition,To,Action,Duration_n,Cost_n,Belief_n,Comfort_n]),
    'elf:builtin'(append(Maps_s,[Map],Maps_t),-),
    'elf:stagecount'(Maps_t,Stagecount),
    'elf:builtin'(Stagecount =< MaxStagecount,-),
    'elf:builtin'(Duration_t is Duration_s+Duration_n,-),
    'elf:builtin'(Duration_t =< MaxDuration,-),
    'elf:builtin'(Cost_t is Cost_s+Cost_n,-),
    'elf:builtin'(Cost_t =< MaxCost,-),
    'elf:builtin'(Belief_t is Belief_s*Belief_n,-),
    'elf:builtin'(Belief_t >= MinBelief,-),
    'elf:builtin'(Comfort_t is Comfort_s*Comfort_n,-),
    'elf:builtin'(Comfort_t >= MinComfort,-),
    'elf:builtin'(append(Path_s,[Action],Path_t),-),
    'elf:becomes'(From,To),
    'elf:builtin'(call_cleanup(
        'elf:findpaths'(Maps_t,[Goal,Path_t,Duration_t,Cost_t,Belief_t,Comfort_t,Path,Duration,Cost,Belief,Comfort,Limits]),
        'elf:becomes'(To,From)
    ),-).

% counting the number of stages (a stage is a sequence of steps in the same map)
'elf:stagecount'([],1).
'elf:stagecount'([C,E|_],B) <=
    'elf:builtin'(C \= E,-),
    'elf:control'(!,-),
    'elf:stagecount'(_,G),
    'elf:builtin'(B is G+1,-).
'elf:stagecount'([_|D],B) <=
    'elf:stagecount'(D,B).

% linear implication
'elf:becomes'(A,B) <=
    'elf:control'(catch(A,_,fail),-),
    'elf:conj_list'(A,C),
    'elf:builtin'(forall(
        'elf:builtin'(member(D,C),-),
        'elf:builtin'(retract(D),-)
    ),-),
    'elf:conj_list'(B,E),
    'elf:builtin'(forall(
        'elf:builtin'(member(F,E),-),
        'elf:builtin'(assertz(F),-)
    ),-).

'elf:conj_list'(true,[]).
'elf:conj_list'(A,[A]) <=
    'elf:builtin'(A \= (_,_),-),
    'elf:builtin'(A \= false,-),
    'elf:control'(!,-).
'elf:conj_list'((A,B),[A|C]) <=
    'elf:conj_list'(B,C).

% test data
'elf:directive'(dynamic('elf:description'/2),-).
'elf:directive'(dynamic('elf:location'/2),-).

% partial map of Belgium
'elf:description'(
    'eg:map_be',
    [   'elf:location'(S,'eg:gent'),
        true,
        'elf:location'(S,'eg:brugge'),
        'eg:drive_gent_brugge',
        1500.0,
        0.006,
        0.96,
        0.99
    ]
).
'elf:description'(
    'eg:map_be',
    [   'elf:location'(S,'eg:gent'),
        true,
        'elf:location'(S,'eg:kortrijk'),
        'eg:drive_gent_kortrijk',
        1600.0,
        0.007,
        0.96,
        0.99
    ]
).
'elf:description'(
    'eg:map_be',
    [   'elf:location'(S,'eg:kortrijk'),
        true,
        'elf:location'(S,'eg:brugge'),
        'eg:drive_kortrijk_brugge',
        1600.0,
        0.007,
        0.96,
        0.99
    ]
).
'elf:description'(
    'eg:map_be',
    [   'elf:location'(S,'eg:brugge'),
        true,
        'elf:location'(S,'eg:oostende'),
        'eg:drive_brugge_oostende',
        900.0,
        0.004,
        0.98,
        1.0
    ]
).

% current state
'elf:location'('eg:i1','eg:gent').

% query
'elf:findpath'(
    'eg:map_be',
    [   'elf:location'(_SUBJECT,'eg:oostende'),
        _PATH,
        _DURATION,
        _COST,
        _BELIEF,
        _COMFORT,
        [5000.0,5.0,0.2,0.4,1]
    ]
) => true.
