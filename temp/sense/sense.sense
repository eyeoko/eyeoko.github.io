% ------------------------------------------------------------
% The sense engine written in the sense notation -- Jos De Roo
% ------------------------------------------------------------
%
% See https://josd.github.io/sense/
%

% prolog bootstrap
:- [sense].

'sense:builtin'(dynamic('sense:brake'/2),-).
'sense:builtin'(dynamic('sense:witness_count'/2),-).
'sense:builtin'(dynamic('sense:domain_predicate'/2),-).
'sense:builtin'(dynamic('sense:answer'/2),-).

%
% sense abstract machine
%
% 1/ select rule P => C
% 2/ prove P and if it fails backtrack to 1/
% 3/ if C = true answer with P => true, else if ~C assert C and retract brake
% 4/ backtrack to 2/ and if it fails backtrack to 1/
% 5/ if 1/ fails and if brake halt, else assert brake and start again at 1/
%
'sense:main'(-,-) <=
    'sense:builtin'(call((Prem => Conc)),-),
    'sense:builtin'(call(Prem),-),
    'sense:process'(Prem,Conc),
    'sense:builtin'(fail,-).
'sense:main'(-,-) <=
    'sense:brake'(-,-),
    'sense:builtin'(halt,-).
'sense:main'(-,-) <=
    'sense:builtin'(assert('sense:brake'(-,-)),-),
    'sense:main'(-,-).

'sense:process'(Prem,true) <=
    'sense:labelvars'(Prem,-),
    'sense:add_answer'(Prem,-).
'sense:process'(Prem,Conc) <=
    'sense:dynify'(Conc,-),
    'sense:builtin'(\+Conc,-),
    'sense:labelvars'(Conc,-),
    'sense:astep'(Prem,Conc),
    'sense:builtin'(retract('sense:brake'(-,-)),-).

'sense:add_answer'(Prem,-) <=
    'sense:builtin'(\+'sense:answer'((Prem => true),-),-),
    'sense:builtin'(assert('sense:answer'((Prem => true),-)),-),
    'sense:builtin'(writeq(Prem),-),
    'sense:builtin'(write(' => true.\n'),-).
'sense:add_answer'(_,-).

'sense:dynify'((A,B),-) <=
    'sense:builtin'(!,-),
    'sense:dynify'(A,-),
    'sense:dynify'(B,-).
'sense:dynify'(A,-) <=
    'sense:builtin'(predicate_property(A,dynamic),-),
    'sense:builtin'(!,-).
'sense:dynify'(A,-) <=
    'sense:builtin'(functor(A,P,2),-),
    'sense:builtin'(dynamic(P/2),-).

% create witnesses
'sense:labelvars'(Term,-) <=
    'sense:builtin'(retract('sense:witness_count'(Current,-)),-),
    'sense:builtin'(!,-),
    'sense:builtin'(numbervars(Term,Current,Next),-),
    'sense:builtin'(assert('sense:witness_count'(Next,-)),-).
'sense:labelvars'(Term,-) <=
    'sense:builtin'(numbervars(Term,0,Next),-),
    'sense:builtin'(assert('sense:witness_count'(Next,-)),-).

% assert new step
'sense:astep'(A,(B,C)) <=
    'sense:astep'(A,B),
    'sense:astep'(A,C).
'sense:astep'(A,false) <=
    'sense:builtin'(writeq(A),-),
    'sense:builtin'(write(' => false.\n'),-),
    'sense:builtin'(halt,-).
'sense:astep'(_,A) <=
    'sense:builtin'(\+A,-),
    'sense:builtin'(assert(A),-),
    'sense:apred'(A,-).
'sense:astep'(_,_).

'sense:apred'(A,-) <=
    'sense:builtin'(functor(A,B,2),-),
    'sense:builtin'(\+'sense:domain_predicate'(B,-),-),
    'sense:builtin'(assert('sense:domain_predicate'(B,-)),-).
'sense:apred'(_,-).
